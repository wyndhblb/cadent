// Code generated by protoc-gen-gogo.
// source: series.proto
// DO NOT EDIT!

/*
	Package series is a generated protocol buffer package.

	It is generated from these files:
		series.proto

	It has these top-level messages:
		MetricType
		MetricName
		MetricValue
		SeriesMetric
		UidMetric
		UidMetricList
		SingleMetric
		SingleMetricList
		UnProcessedMetric
		UnProcessedMetricList
		RawMetric
		RawMetricList
		MetricWritten
		AnyMetric
		AnyMetricList
*/
package series

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import repr "cadent/server/schemas/repr"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type MetricType struct {
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *MetricType) Reset()                    { *m = MetricType{} }
func (m *MetricType) String() string            { return proto.CompactTextString(m) }
func (*MetricType) ProtoMessage()               {}
func (*MetricType) Descriptor() ([]byte, []int) { return fileDescriptorSeries, []int{0} }

// MetricName just the name + metadata
type MetricName struct {
	Metric   string      `protobuf:"bytes,1,opt,name=metric,proto3" json:"metric,omitempty"`
	Id       uint64      `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	Uid      string      `protobuf:"bytes,3,opt,name=uid,proto3" json:"uid,omitempty"`
	Tags     []*repr.Tag `protobuf:"bytes,13,rep,name=tags" json:"tags,omitempty"`
	MetaTags []*repr.Tag `protobuf:"bytes,14,rep,name=meta_tags,json=metaTags" json:"meta_tags,omitempty"`
}

func (m *MetricName) Reset()                    { *m = MetricName{} }
func (m *MetricName) String() string            { return proto.CompactTextString(m) }
func (*MetricName) ProtoMessage()               {}
func (*MetricName) Descriptor() ([]byte, []int) { return fileDescriptorSeries, []int{1} }

// MetricValue just the value (time, data)
type MetricValue struct {
	Time  int64   `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	Min   float64 `protobuf:"fixed64,2,opt,name=min,proto3" json:"min,omitempty"`
	Max   float64 `protobuf:"fixed64,3,opt,name=max,proto3" json:"max,omitempty"`
	Last  float64 `protobuf:"fixed64,4,opt,name=last,proto3" json:"last,omitempty"`
	Sum   float64 `protobuf:"fixed64,5,opt,name=sum,proto3" json:"sum,omitempty"`
	Count int64   `protobuf:"varint,6,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *MetricValue) Reset()                    { *m = MetricValue{} }
func (m *MetricValue) String() string            { return proto.CompactTextString(m) }
func (*MetricValue) ProtoMessage()               {}
func (*MetricValue) Descriptor() ([]byte, []int) { return fileDescriptorSeries, []int{2} }

// SeriesMetric the metric + all the metadata as the series blob
type SeriesMetric struct {
	Id         uint64      `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	Uid        string      `protobuf:"bytes,3,opt,name=uid,proto3" json:"uid,omitempty"`
	Time       int64       `protobuf:"varint,4,opt,name=time,proto3" json:"time,omitempty"`
	Metric     string      `protobuf:"bytes,5,opt,name=metric,proto3" json:"metric,omitempty"`
	Encoding   string      `protobuf:"bytes,6,opt,name=encoding,proto3" json:"encoding,omitempty"`
	Data       []byte      `protobuf:"bytes,7,opt,name=data,proto3" json:"data,omitempty"`
	Resolution uint32      `protobuf:"varint,8,opt,name=resolution,proto3" json:"resolution,omitempty"`
	Ttl        uint32      `protobuf:"varint,9,opt,name=ttl,proto3" json:"ttl,omitempty"`
	Tags       []*repr.Tag `protobuf:"bytes,13,rep,name=tags" json:"tags,omitempty"`
	MetaTags   []*repr.Tag `protobuf:"bytes,14,rep,name=meta_tags,json=metaTags" json:"meta_tags,omitempty"`
	SentTime   int64       `protobuf:"varint,15,opt,name=sent_time,json=sentTime,proto3" json:"sent_time,omitempty"`
}

func (m *SeriesMetric) Reset()                    { *m = SeriesMetric{} }
func (m *SeriesMetric) String() string            { return proto.CompactTextString(m) }
func (*SeriesMetric) ProtoMessage()               {}
func (*SeriesMetric) Descriptor() ([]byte, []int) { return fileDescriptorSeries, []int{3} }

// metric with no metadata just the UID + time + data
type UidMetric struct {
	Uid      string  `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Time     int64   `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	Min      float64 `protobuf:"fixed64,3,opt,name=min,proto3" json:"min,omitempty"`
	Max      float64 `protobuf:"fixed64,4,opt,name=max,proto3" json:"max,omitempty"`
	Last     float64 `protobuf:"fixed64,5,opt,name=last,proto3" json:"last,omitempty"`
	Sum      float64 `protobuf:"fixed64,6,opt,name=sum,proto3" json:"sum,omitempty"`
	Count    int64   `protobuf:"varint,7,opt,name=count,proto3" json:"count,omitempty"`
	SentTime int64   `protobuf:"varint,8,opt,name=sent_time,json=sentTime,proto3" json:"sent_time,omitempty"`
}

func (m *UidMetric) Reset()                    { *m = UidMetric{} }
func (m *UidMetric) String() string            { return proto.CompactTextString(m) }
func (*UidMetric) ProtoMessage()               {}
func (*UidMetric) Descriptor() ([]byte, []int) { return fileDescriptorSeries, []int{4} }

// UidMetricList list of UidMetrics
type UidMetricList struct {
	List []*UidMetricList `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
}

func (m *UidMetricList) Reset()                    { *m = UidMetricList{} }
func (m *UidMetricList) String() string            { return proto.CompactTextString(m) }
func (*UidMetricList) ProtoMessage()               {}
func (*UidMetricList) Descriptor() ([]byte, []int) { return fileDescriptorSeries, []int{5} }

// SingleMetric the metric + all the metadata
type SingleMetric struct {
	Id         uint64      `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	Uid        string      `protobuf:"bytes,3,opt,name=uid,proto3" json:"uid,omitempty"`
	Time       int64       `protobuf:"varint,4,opt,name=time,proto3" json:"time,omitempty"`
	Metric     string      `protobuf:"bytes,5,opt,name=metric,proto3" json:"metric,omitempty"`
	Min        float64     `protobuf:"fixed64,6,opt,name=min,proto3" json:"min,omitempty"`
	Max        float64     `protobuf:"fixed64,7,opt,name=max,proto3" json:"max,omitempty"`
	Last       float64     `protobuf:"fixed64,8,opt,name=last,proto3" json:"last,omitempty"`
	Sum        float64     `protobuf:"fixed64,9,opt,name=sum,proto3" json:"sum,omitempty"`
	Count      int64       `protobuf:"varint,10,opt,name=count,proto3" json:"count,omitempty"`
	Resolution uint32      `protobuf:"varint,11,opt,name=resolution,proto3" json:"resolution,omitempty"`
	Ttl        uint32      `protobuf:"varint,12,opt,name=ttl,proto3" json:"ttl,omitempty"`
	Tags       []*repr.Tag `protobuf:"bytes,13,rep,name=tags" json:"tags,omitempty"`
	MetaTags   []*repr.Tag `protobuf:"bytes,14,rep,name=meta_tags,json=metaTags" json:"meta_tags,omitempty"`
	SentTime   int64       `protobuf:"varint,15,opt,name=sent_time,json=sentTime,proto3" json:"sent_time,omitempty"`
}

func (m *SingleMetric) Reset()                    { *m = SingleMetric{} }
func (m *SingleMetric) String() string            { return proto.CompactTextString(m) }
func (*SingleMetric) ProtoMessage()               {}
func (*SingleMetric) Descriptor() ([]byte, []int) { return fileDescriptorSeries, []int{6} }

// SingleMetricList list of SingleMetrics
type SingleMetricList struct {
	List []*SingleMetric `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
}

func (m *SingleMetricList) Reset()                    { *m = SingleMetricList{} }
func (m *SingleMetricList) String() string            { return proto.CompactTextString(m) }
func (*SingleMetricList) ProtoMessage()               {}
func (*SingleMetricList) Descriptor() ([]byte, []int) { return fileDescriptorSeries, []int{7} }

// UnProcessedMetric the data point + metadata but no "uid/ids"
type UnProcessedMetric struct {
	Time     int64       `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	Metric   string      `protobuf:"bytes,2,opt,name=metric,proto3" json:"metric,omitempty"`
	Min      float64     `protobuf:"fixed64,3,opt,name=min,proto3" json:"min,omitempty"`
	Max      float64     `protobuf:"fixed64,4,opt,name=max,proto3" json:"max,omitempty"`
	Last     float64     `protobuf:"fixed64,5,opt,name=last,proto3" json:"last,omitempty"`
	Sum      float64     `protobuf:"fixed64,6,opt,name=sum,proto3" json:"sum,omitempty"`
	Count    int64       `protobuf:"varint,7,opt,name=count,proto3" json:"count,omitempty"`
	Tags     []*repr.Tag `protobuf:"bytes,13,rep,name=tags" json:"tags,omitempty"`
	MetaTags []*repr.Tag `protobuf:"bytes,14,rep,name=meta_tags,json=metaTags" json:"meta_tags,omitempty"`
	SentTime int64       `protobuf:"varint,15,opt,name=sent_time,json=sentTime,proto3" json:"sent_time,omitempty"`
}

func (m *UnProcessedMetric) Reset()                    { *m = UnProcessedMetric{} }
func (m *UnProcessedMetric) String() string            { return proto.CompactTextString(m) }
func (*UnProcessedMetric) ProtoMessage()               {}
func (*UnProcessedMetric) Descriptor() ([]byte, []int) { return fileDescriptorSeries, []int{8} }

// UnProcessedMetricList list of UnProcessedMetrics
type UnProcessedMetricList struct {
	List []*UnProcessedMetric `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
}

func (m *UnProcessedMetricList) Reset()                    { *m = UnProcessedMetricList{} }
func (m *UnProcessedMetricList) String() string            { return proto.CompactTextString(m) }
func (*UnProcessedMetricList) ProtoMessage()               {}
func (*UnProcessedMetricList) Descriptor() ([]byte, []int) { return fileDescriptorSeries, []int{9} }

// RawMetric non-aggregated metric time+value+metadata
type RawMetric struct {
	Time     int64       `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	Metric   string      `protobuf:"bytes,2,opt,name=metric,proto3" json:"metric,omitempty"`
	Value    float64     `protobuf:"fixed64,3,opt,name=value,proto3" json:"value,omitempty"`
	Tags     []*repr.Tag `protobuf:"bytes,13,rep,name=tags" json:"tags,omitempty"`
	MetaTags []*repr.Tag `protobuf:"bytes,14,rep,name=meta_tags,json=metaTags" json:"meta_tags,omitempty"`
	SentTime int64       `protobuf:"varint,15,opt,name=sent_time,json=sentTime,proto3" json:"sent_time,omitempty"`
}

func (m *RawMetric) Reset()                    { *m = RawMetric{} }
func (m *RawMetric) String() string            { return proto.CompactTextString(m) }
func (*RawMetric) ProtoMessage()               {}
func (*RawMetric) Descriptor() ([]byte, []int) { return fileDescriptorSeries, []int{10} }

// RawMetricList list of RawMetrics
type RawMetricList struct {
	List []*RawMetric `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
}

func (m *RawMetricList) Reset()                    { *m = RawMetricList{} }
func (m *RawMetricList) String() string            { return proto.CompactTextString(m) }
func (*RawMetricList) ProtoMessage()               {}
func (*RawMetricList) Descriptor() ([]byte, []int) { return fileDescriptorSeries, []int{11} }

// MetricWritten this message is meant to be dropped into the bus once we acctually write a
// series, such that on a recover/restart mode we stream all the events, create the series
// then "drop" them if they've been marked as written
// this make recovery much less prone to dropping metrics in the event of down times
type MetricWritten struct {
	Id         uint64      `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	Uid        string      `protobuf:"bytes,3,opt,name=uid,proto3" json:"uid,omitempty"`
	Metric     string      `protobuf:"bytes,4,opt,name=metric,proto3" json:"metric,omitempty"`
	StartTime  int64       `protobuf:"varint,5,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime    int64       `protobuf:"varint,6,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	WriteTime  int64       `protobuf:"varint,7,opt,name=write_time,json=writeTime,proto3" json:"write_time,omitempty"`
	Offset     int64       `protobuf:"varint,8,opt,name=offset,proto3" json:"offset,omitempty"`
	Partition  int32       `protobuf:"varint,9,opt,name=partition,proto3" json:"partition,omitempty"`
	Topic      string      `protobuf:"bytes,10,opt,name=topic,proto3" json:"topic,omitempty"`
	Resolution uint32      `protobuf:"varint,11,opt,name=resolution,proto3" json:"resolution,omitempty"`
	Ttl        uint32      `protobuf:"varint,12,opt,name=ttl,proto3" json:"ttl,omitempty"`
	Tags       []*repr.Tag `protobuf:"bytes,13,rep,name=tags" json:"tags,omitempty"`
	MetaTags   []*repr.Tag `protobuf:"bytes,14,rep,name=meta_tags,json=metaTags" json:"meta_tags,omitempty"`
	SentTime   int64       `protobuf:"varint,15,opt,name=sent_time,json=sentTime,proto3" json:"sent_time,omitempty"`
}

func (m *MetricWritten) Reset()                    { *m = MetricWritten{} }
func (m *MetricWritten) String() string            { return proto.CompactTextString(m) }
func (*MetricWritten) ProtoMessage()               {}
func (*MetricWritten) Descriptor() ([]byte, []int) { return fileDescriptorSeries, []int{12} }

// AnyMetric generic any of the about metrics, only ONE should ever be not nil
type AnyMetric struct {
	Raw         *RawMetric         `protobuf:"bytes,1,opt,name=raw" json:"raw,omitempty"`
	Unprocessed *UnProcessedMetric `protobuf:"bytes,2,opt,name=unprocessed" json:"unprocessed,omitempty"`
	Single      *SingleMetric      `protobuf:"bytes,3,opt,name=single" json:"single,omitempty"`
	Series      *SeriesMetric      `protobuf:"bytes,4,opt,name=series" json:"series,omitempty"`
	UidMetric   *UidMetric         `protobuf:"bytes,5,opt,name=uid_metric,json=uidMetric" json:"uid_metric,omitempty"`
	Written     *MetricWritten     `protobuf:"bytes,6,opt,name=written" json:"written,omitempty"`
}

func (m *AnyMetric) Reset()                    { *m = AnyMetric{} }
func (m *AnyMetric) String() string            { return proto.CompactTextString(m) }
func (*AnyMetric) ProtoMessage()               {}
func (*AnyMetric) Descriptor() ([]byte, []int) { return fileDescriptorSeries, []int{13} }

// AnyMetricList list of anymetrics
type AnyMetricList struct {
	Raw         []*RawMetric         `protobuf:"bytes,1,rep,name=raw" json:"raw,omitempty"`
	Unprocessed []*UnProcessedMetric `protobuf:"bytes,2,rep,name=unprocessed" json:"unprocessed,omitempty"`
	Single      []*SingleMetric      `protobuf:"bytes,3,rep,name=single" json:"single,omitempty"`
	Series      []*SeriesMetric      `protobuf:"bytes,4,rep,name=series" json:"series,omitempty"`
	UidMetric   []*UidMetric         `protobuf:"bytes,5,rep,name=uid_metric,json=uidMetric" json:"uid_metric,omitempty"`
	Written     []*MetricWritten     `protobuf:"bytes,6,rep,name=written" json:"written,omitempty"`
}

func (m *AnyMetricList) Reset()                    { *m = AnyMetricList{} }
func (m *AnyMetricList) String() string            { return proto.CompactTextString(m) }
func (*AnyMetricList) ProtoMessage()               {}
func (*AnyMetricList) Descriptor() ([]byte, []int) { return fileDescriptorSeries, []int{14} }

func init() {
	proto.RegisterType((*MetricType)(nil), "series.MetricType")
	proto.RegisterType((*MetricName)(nil), "series.MetricName")
	proto.RegisterType((*MetricValue)(nil), "series.MetricValue")
	proto.RegisterType((*SeriesMetric)(nil), "series.SeriesMetric")
	proto.RegisterType((*UidMetric)(nil), "series.UidMetric")
	proto.RegisterType((*UidMetricList)(nil), "series.UidMetricList")
	proto.RegisterType((*SingleMetric)(nil), "series.SingleMetric")
	proto.RegisterType((*SingleMetricList)(nil), "series.SingleMetricList")
	proto.RegisterType((*UnProcessedMetric)(nil), "series.UnProcessedMetric")
	proto.RegisterType((*UnProcessedMetricList)(nil), "series.UnProcessedMetricList")
	proto.RegisterType((*RawMetric)(nil), "series.RawMetric")
	proto.RegisterType((*RawMetricList)(nil), "series.RawMetricList")
	proto.RegisterType((*MetricWritten)(nil), "series.MetricWritten")
	proto.RegisterType((*AnyMetric)(nil), "series.AnyMetric")
	proto.RegisterType((*AnyMetricList)(nil), "series.AnyMetricList")
}
func (m *MetricType) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MetricType) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSeries(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	return i, nil
}

func (m *MetricName) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MetricName) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Metric) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSeries(data, i, uint64(len(m.Metric)))
		i += copy(data[i:], m.Metric)
	}
	if m.Id != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSeries(data, i, uint64(m.Id))
	}
	if len(m.Uid) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSeries(data, i, uint64(len(m.Uid)))
		i += copy(data[i:], m.Uid)
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			data[i] = 0x6a
			i++
			i = encodeVarintSeries(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MetaTags) > 0 {
		for _, msg := range m.MetaTags {
			data[i] = 0x72
			i++
			i = encodeVarintSeries(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MetricValue) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MetricValue) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSeries(data, i, uint64(m.Time))
	}
	if m.Min != 0 {
		data[i] = 0x11
		i++
		i = encodeFixed64Series(data, i, uint64(math.Float64bits(float64(m.Min))))
	}
	if m.Max != 0 {
		data[i] = 0x19
		i++
		i = encodeFixed64Series(data, i, uint64(math.Float64bits(float64(m.Max))))
	}
	if m.Last != 0 {
		data[i] = 0x21
		i++
		i = encodeFixed64Series(data, i, uint64(math.Float64bits(float64(m.Last))))
	}
	if m.Sum != 0 {
		data[i] = 0x29
		i++
		i = encodeFixed64Series(data, i, uint64(math.Float64bits(float64(m.Sum))))
	}
	if m.Count != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintSeries(data, i, uint64(m.Count))
	}
	return i, nil
}

func (m *SeriesMetric) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SeriesMetric) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSeries(data, i, uint64(m.Id))
	}
	if len(m.Uid) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSeries(data, i, uint64(len(m.Uid)))
		i += copy(data[i:], m.Uid)
	}
	if m.Time != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintSeries(data, i, uint64(m.Time))
	}
	if len(m.Metric) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSeries(data, i, uint64(len(m.Metric)))
		i += copy(data[i:], m.Metric)
	}
	if len(m.Encoding) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSeries(data, i, uint64(len(m.Encoding)))
		i += copy(data[i:], m.Encoding)
	}
	if len(m.Data) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSeries(data, i, uint64(len(m.Data)))
		i += copy(data[i:], m.Data)
	}
	if m.Resolution != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintSeries(data, i, uint64(m.Resolution))
	}
	if m.Ttl != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintSeries(data, i, uint64(m.Ttl))
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			data[i] = 0x6a
			i++
			i = encodeVarintSeries(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MetaTags) > 0 {
		for _, msg := range m.MetaTags {
			data[i] = 0x72
			i++
			i = encodeVarintSeries(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SentTime != 0 {
		data[i] = 0x78
		i++
		i = encodeVarintSeries(data, i, uint64(m.SentTime))
	}
	return i, nil
}

func (m *UidMetric) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UidMetric) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uid) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSeries(data, i, uint64(len(m.Uid)))
		i += copy(data[i:], m.Uid)
	}
	if m.Time != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSeries(data, i, uint64(m.Time))
	}
	if m.Min != 0 {
		data[i] = 0x19
		i++
		i = encodeFixed64Series(data, i, uint64(math.Float64bits(float64(m.Min))))
	}
	if m.Max != 0 {
		data[i] = 0x21
		i++
		i = encodeFixed64Series(data, i, uint64(math.Float64bits(float64(m.Max))))
	}
	if m.Last != 0 {
		data[i] = 0x29
		i++
		i = encodeFixed64Series(data, i, uint64(math.Float64bits(float64(m.Last))))
	}
	if m.Sum != 0 {
		data[i] = 0x31
		i++
		i = encodeFixed64Series(data, i, uint64(math.Float64bits(float64(m.Sum))))
	}
	if m.Count != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintSeries(data, i, uint64(m.Count))
	}
	if m.SentTime != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintSeries(data, i, uint64(m.SentTime))
	}
	return i, nil
}

func (m *UidMetricList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UidMetricList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			data[i] = 0xa
			i++
			i = encodeVarintSeries(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SingleMetric) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SingleMetric) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSeries(data, i, uint64(m.Id))
	}
	if len(m.Uid) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSeries(data, i, uint64(len(m.Uid)))
		i += copy(data[i:], m.Uid)
	}
	if m.Time != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintSeries(data, i, uint64(m.Time))
	}
	if len(m.Metric) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSeries(data, i, uint64(len(m.Metric)))
		i += copy(data[i:], m.Metric)
	}
	if m.Min != 0 {
		data[i] = 0x31
		i++
		i = encodeFixed64Series(data, i, uint64(math.Float64bits(float64(m.Min))))
	}
	if m.Max != 0 {
		data[i] = 0x39
		i++
		i = encodeFixed64Series(data, i, uint64(math.Float64bits(float64(m.Max))))
	}
	if m.Last != 0 {
		data[i] = 0x41
		i++
		i = encodeFixed64Series(data, i, uint64(math.Float64bits(float64(m.Last))))
	}
	if m.Sum != 0 {
		data[i] = 0x49
		i++
		i = encodeFixed64Series(data, i, uint64(math.Float64bits(float64(m.Sum))))
	}
	if m.Count != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintSeries(data, i, uint64(m.Count))
	}
	if m.Resolution != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintSeries(data, i, uint64(m.Resolution))
	}
	if m.Ttl != 0 {
		data[i] = 0x60
		i++
		i = encodeVarintSeries(data, i, uint64(m.Ttl))
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			data[i] = 0x6a
			i++
			i = encodeVarintSeries(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MetaTags) > 0 {
		for _, msg := range m.MetaTags {
			data[i] = 0x72
			i++
			i = encodeVarintSeries(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SentTime != 0 {
		data[i] = 0x78
		i++
		i = encodeVarintSeries(data, i, uint64(m.SentTime))
	}
	return i, nil
}

func (m *SingleMetricList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SingleMetricList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			data[i] = 0xa
			i++
			i = encodeVarintSeries(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UnProcessedMetric) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UnProcessedMetric) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSeries(data, i, uint64(m.Time))
	}
	if len(m.Metric) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSeries(data, i, uint64(len(m.Metric)))
		i += copy(data[i:], m.Metric)
	}
	if m.Min != 0 {
		data[i] = 0x19
		i++
		i = encodeFixed64Series(data, i, uint64(math.Float64bits(float64(m.Min))))
	}
	if m.Max != 0 {
		data[i] = 0x21
		i++
		i = encodeFixed64Series(data, i, uint64(math.Float64bits(float64(m.Max))))
	}
	if m.Last != 0 {
		data[i] = 0x29
		i++
		i = encodeFixed64Series(data, i, uint64(math.Float64bits(float64(m.Last))))
	}
	if m.Sum != 0 {
		data[i] = 0x31
		i++
		i = encodeFixed64Series(data, i, uint64(math.Float64bits(float64(m.Sum))))
	}
	if m.Count != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintSeries(data, i, uint64(m.Count))
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			data[i] = 0x6a
			i++
			i = encodeVarintSeries(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MetaTags) > 0 {
		for _, msg := range m.MetaTags {
			data[i] = 0x72
			i++
			i = encodeVarintSeries(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SentTime != 0 {
		data[i] = 0x78
		i++
		i = encodeVarintSeries(data, i, uint64(m.SentTime))
	}
	return i, nil
}

func (m *UnProcessedMetricList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UnProcessedMetricList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			data[i] = 0xa
			i++
			i = encodeVarintSeries(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RawMetric) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RawMetric) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSeries(data, i, uint64(m.Time))
	}
	if len(m.Metric) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSeries(data, i, uint64(len(m.Metric)))
		i += copy(data[i:], m.Metric)
	}
	if m.Value != 0 {
		data[i] = 0x19
		i++
		i = encodeFixed64Series(data, i, uint64(math.Float64bits(float64(m.Value))))
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			data[i] = 0x6a
			i++
			i = encodeVarintSeries(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MetaTags) > 0 {
		for _, msg := range m.MetaTags {
			data[i] = 0x72
			i++
			i = encodeVarintSeries(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SentTime != 0 {
		data[i] = 0x78
		i++
		i = encodeVarintSeries(data, i, uint64(m.SentTime))
	}
	return i, nil
}

func (m *RawMetricList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RawMetricList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			data[i] = 0xa
			i++
			i = encodeVarintSeries(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MetricWritten) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MetricWritten) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSeries(data, i, uint64(m.Id))
	}
	if len(m.Uid) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSeries(data, i, uint64(len(m.Uid)))
		i += copy(data[i:], m.Uid)
	}
	if len(m.Metric) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSeries(data, i, uint64(len(m.Metric)))
		i += copy(data[i:], m.Metric)
	}
	if m.StartTime != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintSeries(data, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintSeries(data, i, uint64(m.EndTime))
	}
	if m.WriteTime != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintSeries(data, i, uint64(m.WriteTime))
	}
	if m.Offset != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintSeries(data, i, uint64(m.Offset))
	}
	if m.Partition != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintSeries(data, i, uint64(m.Partition))
	}
	if len(m.Topic) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintSeries(data, i, uint64(len(m.Topic)))
		i += copy(data[i:], m.Topic)
	}
	if m.Resolution != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintSeries(data, i, uint64(m.Resolution))
	}
	if m.Ttl != 0 {
		data[i] = 0x60
		i++
		i = encodeVarintSeries(data, i, uint64(m.Ttl))
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			data[i] = 0x6a
			i++
			i = encodeVarintSeries(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MetaTags) > 0 {
		for _, msg := range m.MetaTags {
			data[i] = 0x72
			i++
			i = encodeVarintSeries(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SentTime != 0 {
		data[i] = 0x78
		i++
		i = encodeVarintSeries(data, i, uint64(m.SentTime))
	}
	return i, nil
}

func (m *AnyMetric) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AnyMetric) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Raw != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSeries(data, i, uint64(m.Raw.Size()))
		n1, err := m.Raw.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Unprocessed != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSeries(data, i, uint64(m.Unprocessed.Size()))
		n2, err := m.Unprocessed.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Single != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSeries(data, i, uint64(m.Single.Size()))
		n3, err := m.Single.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Series != nil {
		data[i] = 0x22
		i++
		i = encodeVarintSeries(data, i, uint64(m.Series.Size()))
		n4, err := m.Series.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.UidMetric != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintSeries(data, i, uint64(m.UidMetric.Size()))
		n5, err := m.UidMetric.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Written != nil {
		data[i] = 0x32
		i++
		i = encodeVarintSeries(data, i, uint64(m.Written.Size()))
		n6, err := m.Written.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *AnyMetricList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AnyMetricList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Raw) > 0 {
		for _, msg := range m.Raw {
			data[i] = 0xa
			i++
			i = encodeVarintSeries(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Unprocessed) > 0 {
		for _, msg := range m.Unprocessed {
			data[i] = 0x12
			i++
			i = encodeVarintSeries(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Single) > 0 {
		for _, msg := range m.Single {
			data[i] = 0x1a
			i++
			i = encodeVarintSeries(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Series) > 0 {
		for _, msg := range m.Series {
			data[i] = 0x22
			i++
			i = encodeVarintSeries(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.UidMetric) > 0 {
		for _, msg := range m.UidMetric {
			data[i] = 0x2a
			i++
			i = encodeVarintSeries(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Written) > 0 {
		for _, msg := range m.Written {
			data[i] = 0x32
			i++
			i = encodeVarintSeries(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Series(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Series(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintSeries(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedMetricType(r randySeries, easy bool) *MetricType {
	this := &MetricType{}
	this.Type = randStringSeries(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMetricName(r randySeries, easy bool) *MetricName {
	this := &MetricName{}
	this.Metric = randStringSeries(r)
	this.Id = uint64(uint64(r.Uint32()))
	this.Uid = randStringSeries(r)
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.Tags = make([]*repr.Tag, v1)
		for i := 0; i < v1; i++ {
			this.Tags[i] = repr.NewPopulatedTag(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v2 := r.Intn(5)
		this.MetaTags = make([]*repr.Tag, v2)
		for i := 0; i < v2; i++ {
			this.MetaTags[i] = repr.NewPopulatedTag(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMetricValue(r randySeries, easy bool) *MetricValue {
	this := &MetricValue{}
	this.Time = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Time *= -1
	}
	this.Min = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Min *= -1
	}
	this.Max = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Max *= -1
	}
	this.Last = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Last *= -1
	}
	this.Sum = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Sum *= -1
	}
	this.Count = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Count *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSeriesMetric(r randySeries, easy bool) *SeriesMetric {
	this := &SeriesMetric{}
	this.Id = uint64(uint64(r.Uint32()))
	this.Uid = randStringSeries(r)
	this.Time = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Time *= -1
	}
	this.Metric = randStringSeries(r)
	this.Encoding = randStringSeries(r)
	v3 := r.Intn(100)
	this.Data = make([]byte, v3)
	for i := 0; i < v3; i++ {
		this.Data[i] = byte(r.Intn(256))
	}
	this.Resolution = uint32(r.Uint32())
	this.Ttl = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v4 := r.Intn(5)
		this.Tags = make([]*repr.Tag, v4)
		for i := 0; i < v4; i++ {
			this.Tags[i] = repr.NewPopulatedTag(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v5 := r.Intn(5)
		this.MetaTags = make([]*repr.Tag, v5)
		for i := 0; i < v5; i++ {
			this.MetaTags[i] = repr.NewPopulatedTag(r, easy)
		}
	}
	this.SentTime = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.SentTime *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUidMetric(r randySeries, easy bool) *UidMetric {
	this := &UidMetric{}
	this.Uid = randStringSeries(r)
	this.Time = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Time *= -1
	}
	this.Min = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Min *= -1
	}
	this.Max = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Max *= -1
	}
	this.Last = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Last *= -1
	}
	this.Sum = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Sum *= -1
	}
	this.Count = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Count *= -1
	}
	this.SentTime = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.SentTime *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUidMetricList(r randySeries, easy bool) *UidMetricList {
	this := &UidMetricList{}
	if r.Intn(10) == 0 {
		v6 := r.Intn(5)
		this.List = make([]*UidMetricList, v6)
		for i := 0; i < v6; i++ {
			this.List[i] = NewPopulatedUidMetricList(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSingleMetric(r randySeries, easy bool) *SingleMetric {
	this := &SingleMetric{}
	this.Id = uint64(uint64(r.Uint32()))
	this.Uid = randStringSeries(r)
	this.Time = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Time *= -1
	}
	this.Metric = randStringSeries(r)
	this.Min = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Min *= -1
	}
	this.Max = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Max *= -1
	}
	this.Last = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Last *= -1
	}
	this.Sum = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Sum *= -1
	}
	this.Count = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Count *= -1
	}
	this.Resolution = uint32(r.Uint32())
	this.Ttl = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v7 := r.Intn(5)
		this.Tags = make([]*repr.Tag, v7)
		for i := 0; i < v7; i++ {
			this.Tags[i] = repr.NewPopulatedTag(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v8 := r.Intn(5)
		this.MetaTags = make([]*repr.Tag, v8)
		for i := 0; i < v8; i++ {
			this.MetaTags[i] = repr.NewPopulatedTag(r, easy)
		}
	}
	this.SentTime = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.SentTime *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSingleMetricList(r randySeries, easy bool) *SingleMetricList {
	this := &SingleMetricList{}
	if r.Intn(10) != 0 {
		v9 := r.Intn(5)
		this.List = make([]*SingleMetric, v9)
		for i := 0; i < v9; i++ {
			this.List[i] = NewPopulatedSingleMetric(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUnProcessedMetric(r randySeries, easy bool) *UnProcessedMetric {
	this := &UnProcessedMetric{}
	this.Time = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Time *= -1
	}
	this.Metric = randStringSeries(r)
	this.Min = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Min *= -1
	}
	this.Max = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Max *= -1
	}
	this.Last = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Last *= -1
	}
	this.Sum = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Sum *= -1
	}
	this.Count = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Count *= -1
	}
	if r.Intn(10) != 0 {
		v10 := r.Intn(5)
		this.Tags = make([]*repr.Tag, v10)
		for i := 0; i < v10; i++ {
			this.Tags[i] = repr.NewPopulatedTag(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v11 := r.Intn(5)
		this.MetaTags = make([]*repr.Tag, v11)
		for i := 0; i < v11; i++ {
			this.MetaTags[i] = repr.NewPopulatedTag(r, easy)
		}
	}
	this.SentTime = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.SentTime *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUnProcessedMetricList(r randySeries, easy bool) *UnProcessedMetricList {
	this := &UnProcessedMetricList{}
	if r.Intn(10) != 0 {
		v12 := r.Intn(5)
		this.List = make([]*UnProcessedMetric, v12)
		for i := 0; i < v12; i++ {
			this.List[i] = NewPopulatedUnProcessedMetric(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRawMetric(r randySeries, easy bool) *RawMetric {
	this := &RawMetric{}
	this.Time = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Time *= -1
	}
	this.Metric = randStringSeries(r)
	this.Value = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Value *= -1
	}
	if r.Intn(10) != 0 {
		v13 := r.Intn(5)
		this.Tags = make([]*repr.Tag, v13)
		for i := 0; i < v13; i++ {
			this.Tags[i] = repr.NewPopulatedTag(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v14 := r.Intn(5)
		this.MetaTags = make([]*repr.Tag, v14)
		for i := 0; i < v14; i++ {
			this.MetaTags[i] = repr.NewPopulatedTag(r, easy)
		}
	}
	this.SentTime = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.SentTime *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRawMetricList(r randySeries, easy bool) *RawMetricList {
	this := &RawMetricList{}
	if r.Intn(10) != 0 {
		v15 := r.Intn(5)
		this.List = make([]*RawMetric, v15)
		for i := 0; i < v15; i++ {
			this.List[i] = NewPopulatedRawMetric(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMetricWritten(r randySeries, easy bool) *MetricWritten {
	this := &MetricWritten{}
	this.Id = uint64(uint64(r.Uint32()))
	this.Uid = randStringSeries(r)
	this.Metric = randStringSeries(r)
	this.StartTime = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.StartTime *= -1
	}
	this.EndTime = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.EndTime *= -1
	}
	this.WriteTime = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.WriteTime *= -1
	}
	this.Offset = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Offset *= -1
	}
	this.Partition = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Partition *= -1
	}
	this.Topic = randStringSeries(r)
	this.Resolution = uint32(r.Uint32())
	this.Ttl = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v16 := r.Intn(5)
		this.Tags = make([]*repr.Tag, v16)
		for i := 0; i < v16; i++ {
			this.Tags[i] = repr.NewPopulatedTag(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v17 := r.Intn(5)
		this.MetaTags = make([]*repr.Tag, v17)
		for i := 0; i < v17; i++ {
			this.MetaTags[i] = repr.NewPopulatedTag(r, easy)
		}
	}
	this.SentTime = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.SentTime *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAnyMetric(r randySeries, easy bool) *AnyMetric {
	this := &AnyMetric{}
	if r.Intn(10) != 0 {
		this.Raw = NewPopulatedRawMetric(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Unprocessed = NewPopulatedUnProcessedMetric(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Single = NewPopulatedSingleMetric(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Series = NewPopulatedSeriesMetric(r, easy)
	}
	if r.Intn(10) != 0 {
		this.UidMetric = NewPopulatedUidMetric(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Written = NewPopulatedMetricWritten(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAnyMetricList(r randySeries, easy bool) *AnyMetricList {
	this := &AnyMetricList{}
	if r.Intn(10) != 0 {
		v18 := r.Intn(5)
		this.Raw = make([]*RawMetric, v18)
		for i := 0; i < v18; i++ {
			this.Raw[i] = NewPopulatedRawMetric(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v19 := r.Intn(5)
		this.Unprocessed = make([]*UnProcessedMetric, v19)
		for i := 0; i < v19; i++ {
			this.Unprocessed[i] = NewPopulatedUnProcessedMetric(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v20 := r.Intn(5)
		this.Single = make([]*SingleMetric, v20)
		for i := 0; i < v20; i++ {
			this.Single[i] = NewPopulatedSingleMetric(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v21 := r.Intn(5)
		this.Series = make([]*SeriesMetric, v21)
		for i := 0; i < v21; i++ {
			this.Series[i] = NewPopulatedSeriesMetric(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v22 := r.Intn(5)
		this.UidMetric = make([]*UidMetric, v22)
		for i := 0; i < v22; i++ {
			this.UidMetric[i] = NewPopulatedUidMetric(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v23 := r.Intn(5)
		this.Written = make([]*MetricWritten, v23)
		for i := 0; i < v23; i++ {
			this.Written[i] = NewPopulatedMetricWritten(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randySeries interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneSeries(r randySeries) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringSeries(r randySeries) string {
	v24 := r.Intn(100)
	tmps := make([]rune, v24)
	for i := 0; i < v24; i++ {
		tmps[i] = randUTF8RuneSeries(r)
	}
	return string(tmps)
}
func randUnrecognizedSeries(r randySeries, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldSeries(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldSeries(data []byte, r randySeries, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateSeries(data, uint64(key))
		v25 := r.Int63()
		if r.Intn(2) == 0 {
			v25 *= -1
		}
		data = encodeVarintPopulateSeries(data, uint64(v25))
	case 1:
		data = encodeVarintPopulateSeries(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateSeries(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateSeries(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateSeries(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateSeries(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (m *MetricType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSeries(uint64(l))
	}
	return n
}

func (m *MetricName) Size() (n int) {
	var l int
	_ = l
	l = len(m.Metric)
	if l > 0 {
		n += 1 + l + sovSeries(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovSeries(uint64(m.Id))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovSeries(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovSeries(uint64(l))
		}
	}
	if len(m.MetaTags) > 0 {
		for _, e := range m.MetaTags {
			l = e.Size()
			n += 1 + l + sovSeries(uint64(l))
		}
	}
	return n
}

func (m *MetricValue) Size() (n int) {
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovSeries(uint64(m.Time))
	}
	if m.Min != 0 {
		n += 9
	}
	if m.Max != 0 {
		n += 9
	}
	if m.Last != 0 {
		n += 9
	}
	if m.Sum != 0 {
		n += 9
	}
	if m.Count != 0 {
		n += 1 + sovSeries(uint64(m.Count))
	}
	return n
}

func (m *SeriesMetric) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovSeries(uint64(m.Id))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovSeries(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovSeries(uint64(m.Time))
	}
	l = len(m.Metric)
	if l > 0 {
		n += 1 + l + sovSeries(uint64(l))
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovSeries(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovSeries(uint64(l))
	}
	if m.Resolution != 0 {
		n += 1 + sovSeries(uint64(m.Resolution))
	}
	if m.Ttl != 0 {
		n += 1 + sovSeries(uint64(m.Ttl))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovSeries(uint64(l))
		}
	}
	if len(m.MetaTags) > 0 {
		for _, e := range m.MetaTags {
			l = e.Size()
			n += 1 + l + sovSeries(uint64(l))
		}
	}
	if m.SentTime != 0 {
		n += 1 + sovSeries(uint64(m.SentTime))
	}
	return n
}

func (m *UidMetric) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovSeries(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovSeries(uint64(m.Time))
	}
	if m.Min != 0 {
		n += 9
	}
	if m.Max != 0 {
		n += 9
	}
	if m.Last != 0 {
		n += 9
	}
	if m.Sum != 0 {
		n += 9
	}
	if m.Count != 0 {
		n += 1 + sovSeries(uint64(m.Count))
	}
	if m.SentTime != 0 {
		n += 1 + sovSeries(uint64(m.SentTime))
	}
	return n
}

func (m *UidMetricList) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovSeries(uint64(l))
		}
	}
	return n
}

func (m *SingleMetric) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovSeries(uint64(m.Id))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovSeries(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovSeries(uint64(m.Time))
	}
	l = len(m.Metric)
	if l > 0 {
		n += 1 + l + sovSeries(uint64(l))
	}
	if m.Min != 0 {
		n += 9
	}
	if m.Max != 0 {
		n += 9
	}
	if m.Last != 0 {
		n += 9
	}
	if m.Sum != 0 {
		n += 9
	}
	if m.Count != 0 {
		n += 1 + sovSeries(uint64(m.Count))
	}
	if m.Resolution != 0 {
		n += 1 + sovSeries(uint64(m.Resolution))
	}
	if m.Ttl != 0 {
		n += 1 + sovSeries(uint64(m.Ttl))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovSeries(uint64(l))
		}
	}
	if len(m.MetaTags) > 0 {
		for _, e := range m.MetaTags {
			l = e.Size()
			n += 1 + l + sovSeries(uint64(l))
		}
	}
	if m.SentTime != 0 {
		n += 1 + sovSeries(uint64(m.SentTime))
	}
	return n
}

func (m *SingleMetricList) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovSeries(uint64(l))
		}
	}
	return n
}

func (m *UnProcessedMetric) Size() (n int) {
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovSeries(uint64(m.Time))
	}
	l = len(m.Metric)
	if l > 0 {
		n += 1 + l + sovSeries(uint64(l))
	}
	if m.Min != 0 {
		n += 9
	}
	if m.Max != 0 {
		n += 9
	}
	if m.Last != 0 {
		n += 9
	}
	if m.Sum != 0 {
		n += 9
	}
	if m.Count != 0 {
		n += 1 + sovSeries(uint64(m.Count))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovSeries(uint64(l))
		}
	}
	if len(m.MetaTags) > 0 {
		for _, e := range m.MetaTags {
			l = e.Size()
			n += 1 + l + sovSeries(uint64(l))
		}
	}
	if m.SentTime != 0 {
		n += 1 + sovSeries(uint64(m.SentTime))
	}
	return n
}

func (m *UnProcessedMetricList) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovSeries(uint64(l))
		}
	}
	return n
}

func (m *RawMetric) Size() (n int) {
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovSeries(uint64(m.Time))
	}
	l = len(m.Metric)
	if l > 0 {
		n += 1 + l + sovSeries(uint64(l))
	}
	if m.Value != 0 {
		n += 9
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovSeries(uint64(l))
		}
	}
	if len(m.MetaTags) > 0 {
		for _, e := range m.MetaTags {
			l = e.Size()
			n += 1 + l + sovSeries(uint64(l))
		}
	}
	if m.SentTime != 0 {
		n += 1 + sovSeries(uint64(m.SentTime))
	}
	return n
}

func (m *RawMetricList) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovSeries(uint64(l))
		}
	}
	return n
}

func (m *MetricWritten) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovSeries(uint64(m.Id))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovSeries(uint64(l))
	}
	l = len(m.Metric)
	if l > 0 {
		n += 1 + l + sovSeries(uint64(l))
	}
	if m.StartTime != 0 {
		n += 1 + sovSeries(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovSeries(uint64(m.EndTime))
	}
	if m.WriteTime != 0 {
		n += 1 + sovSeries(uint64(m.WriteTime))
	}
	if m.Offset != 0 {
		n += 1 + sovSeries(uint64(m.Offset))
	}
	if m.Partition != 0 {
		n += 1 + sovSeries(uint64(m.Partition))
	}
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSeries(uint64(l))
	}
	if m.Resolution != 0 {
		n += 1 + sovSeries(uint64(m.Resolution))
	}
	if m.Ttl != 0 {
		n += 1 + sovSeries(uint64(m.Ttl))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovSeries(uint64(l))
		}
	}
	if len(m.MetaTags) > 0 {
		for _, e := range m.MetaTags {
			l = e.Size()
			n += 1 + l + sovSeries(uint64(l))
		}
	}
	if m.SentTime != 0 {
		n += 1 + sovSeries(uint64(m.SentTime))
	}
	return n
}

func (m *AnyMetric) Size() (n int) {
	var l int
	_ = l
	if m.Raw != nil {
		l = m.Raw.Size()
		n += 1 + l + sovSeries(uint64(l))
	}
	if m.Unprocessed != nil {
		l = m.Unprocessed.Size()
		n += 1 + l + sovSeries(uint64(l))
	}
	if m.Single != nil {
		l = m.Single.Size()
		n += 1 + l + sovSeries(uint64(l))
	}
	if m.Series != nil {
		l = m.Series.Size()
		n += 1 + l + sovSeries(uint64(l))
	}
	if m.UidMetric != nil {
		l = m.UidMetric.Size()
		n += 1 + l + sovSeries(uint64(l))
	}
	if m.Written != nil {
		l = m.Written.Size()
		n += 1 + l + sovSeries(uint64(l))
	}
	return n
}

func (m *AnyMetricList) Size() (n int) {
	var l int
	_ = l
	if len(m.Raw) > 0 {
		for _, e := range m.Raw {
			l = e.Size()
			n += 1 + l + sovSeries(uint64(l))
		}
	}
	if len(m.Unprocessed) > 0 {
		for _, e := range m.Unprocessed {
			l = e.Size()
			n += 1 + l + sovSeries(uint64(l))
		}
	}
	if len(m.Single) > 0 {
		for _, e := range m.Single {
			l = e.Size()
			n += 1 + l + sovSeries(uint64(l))
		}
	}
	if len(m.Series) > 0 {
		for _, e := range m.Series {
			l = e.Size()
			n += 1 + l + sovSeries(uint64(l))
		}
	}
	if len(m.UidMetric) > 0 {
		for _, e := range m.UidMetric {
			l = e.Size()
			n += 1 + l + sovSeries(uint64(l))
		}
	}
	if len(m.Written) > 0 {
		for _, e := range m.Written {
			l = e.Size()
			n += 1 + l + sovSeries(uint64(l))
		}
	}
	return n
}

func sovSeries(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSeries(x uint64) (n int) {
	return sovSeries(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MetricType) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeries
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeries(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeries
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricName) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeries
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metric = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &repr.Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaTags = append(m.MetaTags, &repr.Tag{})
			if err := m.MetaTags[len(m.MetaTags)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeries(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeries
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricValue) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeries
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Min = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Max = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Last", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Last = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Sum = float64(math.Float64frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeries(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeries
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeriesMetric) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeries
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeriesMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeriesMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metric = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], data[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
			}
			m.Resolution = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Resolution |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ttl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &repr.Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaTags = append(m.MetaTags, &repr.Tag{})
			if err := m.MetaTags[len(m.MetaTags)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SentTime", wireType)
			}
			m.SentTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SentTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeries(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeries
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UidMetric) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeries
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UidMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UidMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Min = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Max = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Last", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Last = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Sum = float64(math.Float64frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SentTime", wireType)
			}
			m.SentTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SentTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeries(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeries
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UidMetricList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeries
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UidMetricList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UidMetricList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &UidMetricList{})
			if err := m.List[len(m.List)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeries(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeries
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SingleMetric) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeries
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metric = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Min = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Max = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Last", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Last = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Sum = float64(math.Float64frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
			}
			m.Resolution = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Resolution |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ttl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &repr.Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaTags = append(m.MetaTags, &repr.Tag{})
			if err := m.MetaTags[len(m.MetaTags)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SentTime", wireType)
			}
			m.SentTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SentTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeries(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeries
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SingleMetricList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeries
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleMetricList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleMetricList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &SingleMetric{})
			if err := m.List[len(m.List)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeries(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeries
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnProcessedMetric) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeries
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnProcessedMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnProcessedMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metric = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Min = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Max = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Last", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Last = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Sum = float64(math.Float64frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &repr.Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaTags = append(m.MetaTags, &repr.Tag{})
			if err := m.MetaTags[len(m.MetaTags)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SentTime", wireType)
			}
			m.SentTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SentTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeries(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeries
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnProcessedMetricList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeries
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnProcessedMetricList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnProcessedMetricList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &UnProcessedMetric{})
			if err := m.List[len(m.List)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeries(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeries
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawMetric) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeries
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metric = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Value = float64(math.Float64frombits(v))
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &repr.Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaTags = append(m.MetaTags, &repr.Tag{})
			if err := m.MetaTags[len(m.MetaTags)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SentTime", wireType)
			}
			m.SentTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SentTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeries(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeries
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawMetricList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeries
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawMetricList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawMetricList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &RawMetric{})
			if err := m.List[len(m.List)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeries(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeries
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricWritten) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeries
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricWritten: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricWritten: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metric = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteTime", wireType)
			}
			m.WriteTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.WriteTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Offset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Partition |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
			}
			m.Resolution = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Resolution |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ttl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &repr.Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaTags = append(m.MetaTags, &repr.Tag{})
			if err := m.MetaTags[len(m.MetaTags)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SentTime", wireType)
			}
			m.SentTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SentTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeries(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeries
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnyMetric) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeries
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnyMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnyMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Raw == nil {
				m.Raw = &RawMetric{}
			}
			if err := m.Raw.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unprocessed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Unprocessed == nil {
				m.Unprocessed = &UnProcessedMetric{}
			}
			if err := m.Unprocessed.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Single", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Single == nil {
				m.Single = &SingleMetric{}
			}
			if err := m.Single.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Series == nil {
				m.Series = &SeriesMetric{}
			}
			if err := m.Series.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UidMetric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UidMetric == nil {
				m.UidMetric = &UidMetric{}
			}
			if err := m.UidMetric.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Written", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Written == nil {
				m.Written = &MetricWritten{}
			}
			if err := m.Written.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeries(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeries
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnyMetricList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeries
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnyMetricList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnyMetricList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Raw = append(m.Raw, &RawMetric{})
			if err := m.Raw[len(m.Raw)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unprocessed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unprocessed = append(m.Unprocessed, &UnProcessedMetric{})
			if err := m.Unprocessed[len(m.Unprocessed)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Single", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Single = append(m.Single, &SingleMetric{})
			if err := m.Single[len(m.Single)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Series = append(m.Series, &SeriesMetric{})
			if err := m.Series[len(m.Series)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UidMetric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UidMetric = append(m.UidMetric, &UidMetric{})
			if err := m.UidMetric[len(m.UidMetric)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Written", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeries
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Written = append(m.Written, &MetricWritten{})
			if err := m.Written[len(m.Written)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeries(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeries
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSeries(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSeries
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSeries
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSeries
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSeries
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSeries(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSeries = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSeries   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("series.proto", fileDescriptorSeries) }

var fileDescriptorSeries = []byte{
	// 873 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xcc, 0x56, 0xcf, 0x8f, 0xdb, 0x44,
	0x14, 0xee, 0xd8, 0xce, 0x0f, 0xbf, 0xdd, 0x94, 0x76, 0xb4, 0x45, 0xee, 0xd2, 0xb5, 0xa2, 0xa0,
	0xa2, 0x20, 0xd1, 0x0d, 0x02, 0x89, 0x03, 0x70, 0x81, 0x03, 0x27, 0x8a, 0x90, 0x49, 0xe1, 0xb8,
	0x9a, 0xb5, 0x67, 0xdd, 0x91, 0x62, 0x3b, 0xf2, 0x8c, 0xbb, 0xdd, 0x23, 0x82, 0x2b, 0x12, 0x7f,
	0x03, 0x67, 0x84, 0xe0, 0x3f, 0xe0, 0xd8, 0x23, 0xe2, 0x2f, 0xa0, 0xe1, 0x9f, 0xe0, 0x88, 0xe6,
	0xcd, 0xc4, 0xb1, 0xd7, 0x29, 0x34, 0x15, 0x5d, 0x71, 0x89, 0xe6, 0xbd, 0xf9, 0x92, 0x7c, 0xef,
	0xfb, 0xbe, 0x19, 0x1b, 0xf6, 0x25, 0x2f, 0x05, 0x97, 0xc7, 0xcb, 0xb2, 0x50, 0x05, 0xed, 0x9b,
	0xea, 0xf0, 0x5e, 0x2a, 0xd4, 0xc3, 0xea, 0xf4, 0x38, 0x2e, 0xb2, 0x59, 0x5a, 0xa4, 0xc5, 0x0c,
	0xb7, 0x4f, 0xab, 0x33, 0xac, 0xb0, 0xc0, 0x95, 0xf9, 0xda, 0xe1, 0xdd, 0x98, 0x25, 0x3c, 0x57,
	0x33, 0xc9, 0xcb, 0x47, 0xbc, 0x9c, 0xc9, 0xf8, 0x21, 0xcf, 0x98, 0x9c, 0x95, 0x7c, 0x59, 0xe2,
	0x87, 0x81, 0x4d, 0xc6, 0x00, 0xf7, 0xb9, 0x2a, 0x45, 0x3c, 0xbf, 0x58, 0x72, 0x4a, 0xc1, 0x53,
	0x17, 0x4b, 0x1e, 0x90, 0x31, 0x99, 0xfa, 0x11, 0xae, 0x27, 0xdf, 0x91, 0x35, 0xe4, 0x33, 0x96,
	0x71, 0xfa, 0x2a, 0xf4, 0x33, 0xac, 0x2c, 0xc8, 0x56, 0xf4, 0x3a, 0x38, 0x22, 0x09, 0x9c, 0x31,
	0x99, 0x7a, 0x91, 0x23, 0x12, 0x7a, 0x03, 0xdc, 0x4a, 0x24, 0x81, 0x8b, 0x20, 0xbd, 0xa4, 0x47,
	0xe0, 0x29, 0x96, 0xca, 0x60, 0x34, 0x76, 0xa7, 0x7b, 0xef, 0xf8, 0xc7, 0xc8, 0x62, 0xce, 0xd2,
	0x08, 0xdb, 0xf4, 0x0d, 0xf0, 0x33, 0xae, 0xd8, 0x09, 0x62, 0xae, 0x5f, 0xc6, 0x0c, 0xf5, 0xde,
	0x9c, 0xa5, 0x72, 0xf2, 0x35, 0x81, 0x3d, 0xc3, 0xe7, 0x4b, 0xb6, 0xa8, 0x0c, 0x67, 0x91, 0x19,
	0xce, 0x6e, 0x84, 0x6b, 0xfd, 0xe7, 0x99, 0xc8, 0x91, 0x0d, 0x89, 0xf4, 0x12, 0x3b, 0xec, 0x31,
	0xd2, 0xd1, 0x1d, 0xf6, 0x58, 0x7f, 0x6f, 0xc1, 0xa4, 0x0a, 0x3c, 0x6c, 0xe1, 0x5a, 0xa3, 0x64,
	0x95, 0x05, 0x3d, 0x83, 0x92, 0x55, 0x46, 0x0f, 0xa0, 0x17, 0x17, 0x55, 0xae, 0x82, 0x3e, 0xfe,
	0xbc, 0x29, 0x26, 0x3f, 0x38, 0xb0, 0xff, 0x05, 0xda, 0x72, 0xff, 0x79, 0xa7, 0x5f, 0xd3, 0xf4,
	0x1a, 0x34, 0x37, 0x5a, 0xf6, 0x5a, 0x5a, 0x1e, 0xc2, 0x90, 0xe7, 0x71, 0x91, 0x88, 0x3c, 0xc5,
	0xff, 0xf5, 0xa3, 0xba, 0xd6, 0xbf, 0x93, 0x30, 0xc5, 0x82, 0xc1, 0x98, 0x4c, 0xf7, 0x23, 0x5c,
	0xd3, 0x10, 0xa0, 0xe4, 0xb2, 0x58, 0x54, 0x4a, 0x14, 0x79, 0x30, 0x1c, 0x93, 0xe9, 0x28, 0x6a,
	0x74, 0x34, 0x1b, 0xa5, 0x16, 0x81, 0x8f, 0x1b, 0x7a, 0xf9, 0x1f, 0x79, 0x41, 0x5f, 0x03, 0x5f,
	0xf2, 0x5c, 0x9d, 0xe0, 0x64, 0xaf, 0xe0, 0x64, 0x43, 0xdd, 0x98, 0x8b, 0x8c, 0x4f, 0x7e, 0x22,
	0xe0, 0x3f, 0x10, 0x89, 0x55, 0xc8, 0x2a, 0x42, 0xba, 0x8a, 0x38, 0x5d, 0xe3, 0xdc, 0x8e, 0x71,
	0x5e, 0xd7, 0xb8, 0x5e, 0xd7, 0xb8, 0xfe, 0x16, 0xe3, 0x06, 0x0d, 0xe3, 0xda, 0x84, 0x87, 0x97,
	0x08, 0xbf, 0x0f, 0xa3, 0x9a, 0xef, 0xa7, 0x42, 0x2a, 0xfa, 0x26, 0x78, 0x0b, 0x21, 0x55, 0x40,
	0x50, 0x81, 0x5b, 0xc7, 0xf6, 0x5c, 0xb6, 0x40, 0x11, 0x42, 0x26, 0xbf, 0xeb, 0x44, 0x88, 0x3c,
	0x5d, 0xf0, 0x97, 0x92, 0x08, 0xab, 0x4b, 0xbf, 0xa3, 0xcb, 0xa0, 0xab, 0xcb, 0xb0, 0xab, 0x8b,
	0xbf, 0x45, 0x17, 0x68, 0xea, 0xd2, 0x4e, 0xd0, 0xde, 0xb3, 0x12, 0xb4, 0x7f, 0xb5, 0x09, 0xfa,
	0x10, 0x6e, 0x34, 0x35, 0x45, 0x4f, 0xa6, 0x2d, 0x4f, 0x0e, 0xd6, 0x9e, 0x34, 0x71, 0xd6, 0x92,
	0x6f, 0x1c, 0xb8, 0xf9, 0x20, 0xff, 0xbc, 0x2c, 0x62, 0x2e, 0x25, 0x5f, 0xe7, 0x70, 0xdb, 0x75,
	0xb1, 0x51, 0xdd, 0xd9, 0xa6, 0xfa, 0x4b, 0x4b, 0xe3, 0x55, 0x68, 0xf8, 0x09, 0xdc, 0xea, 0x88,
	0x80, 0x42, 0xde, 0x6b, 0x09, 0x79, 0xbb, 0x0e, 0xf7, 0x65, 0xb0, 0x55, 0xf3, 0x17, 0x02, 0x7e,
	0xc4, 0xce, 0x5f, 0x40, 0xc5, 0x03, 0xe8, 0x3d, 0xd2, 0x37, 0xb5, 0xd5, 0xd1, 0x14, 0x57, 0x32,
	0xfb, 0x7b, 0x30, 0xaa, 0x29, 0xe3, 0xcc, 0x77, 0x5b, 0x33, 0xdf, 0x5c, 0xcf, 0x5c, 0x83, 0xec,
	0xac, 0xdf, 0xba, 0x30, 0x32, 0x8d, 0xaf, 0x4a, 0xa1, 0x14, 0xcf, 0x9f, 0xe3, 0x34, 0x6f, 0xa6,
	0xf7, 0x5a, 0xd3, 0x1f, 0x01, 0x48, 0xc5, 0x4a, 0xcb, 0xb0, 0x87, 0x0c, 0x7d, 0xec, 0x68, 0x8a,
	0xf4, 0xb6, 0xbe, 0xea, 0x13, 0xb3, 0x69, 0x1e, 0x31, 0x03, 0x9e, 0x27, 0xb8, 0x75, 0x04, 0x70,
	0x5e, 0x0a, 0xc5, 0xcd, 0xa6, 0x09, 0x8e, 0x8f, 0x9d, 0xb9, 0x95, 0xbb, 0x38, 0x3b, 0x93, 0x5c,
	0xd9, 0x7b, 0xcc, 0x56, 0xf4, 0x0e, 0xf8, 0x4b, 0x56, 0x2a, 0x81, 0x27, 0x59, 0x1f, 0xfc, 0x5e,
	0xb4, 0x69, 0x68, 0x33, 0x54, 0xb1, 0x14, 0x31, 0x1e, 0x7f, 0x3f, 0x32, 0xc5, 0xff, 0xf4, 0xf8,
	0xff, 0xe8, 0x80, 0xff, 0x51, 0x7e, 0x61, 0x23, 0xf7, 0x3a, 0xb8, 0x25, 0x3b, 0xc7, 0xc4, 0x6d,
	0xb5, 0x4e, 0xef, 0xd2, 0x0f, 0x60, 0xaf, 0xca, 0x97, 0xeb, 0x00, 0xa3, 0x61, 0xff, 0x98, 0xed,
	0x26, 0x9a, 0xbe, 0x05, 0x7d, 0x89, 0xd7, 0x08, 0xfa, 0xfa, 0xac, 0xcb, 0xc5, 0x62, 0x10, 0x8d,
	0xdb, 0x68, 0x78, 0x13, 0xdd, 0x78, 0x31, 0x88, 0x2c, 0x86, 0xbe, 0x0d, 0x50, 0x89, 0xe4, 0xa4,
	0x71, 0xb9, 0x37, 0x86, 0xa8, 0x1f, 0x28, 0x91, 0x5f, 0xd5, 0x0f, 0xcc, 0x19, 0x0c, 0xce, 0x4d,
	0xfa, 0x30, 0x18, 0x8d, 0xe7, 0x4f, 0x2b, 0x9a, 0xd1, 0x1a, 0x35, 0xf9, 0xd9, 0x81, 0x51, 0x2d,
	0x17, 0xc6, 0xbd, 0x96, 0xcc, 0xdd, 0x45, 0x32, 0xf7, 0x05, 0x25, 0x73, 0x77, 0x92, 0xcc, 0xdd,
	0x59, 0x32, 0x77, 0x37, 0xc9, 0xdc, 0x7f, 0x97, 0xec, 0xe3, 0x3b, 0x4f, 0x9e, 0x86, 0xd7, 0xfe,
	0x7a, 0x1a, 0x92, 0x5f, 0x57, 0x21, 0x79, 0xb2, 0x0a, 0xc9, 0x6f, 0xab, 0x90, 0xfc, 0xb1, 0x0a,
	0xc9, 0xf7, 0x7f, 0x86, 0xd7, 0x4e, 0xfb, 0xf8, 0x8a, 0xfc, 0xee, 0xdf, 0x01, 0x00, 0x00, 0xff,
	0xff, 0x0b, 0x52, 0x40, 0x67, 0x90, 0x0b, 0x00, 0x00,
}
