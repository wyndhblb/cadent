// Code generated by protoc-gen-go.
// source: cadent.proto
// DO NOT EDIT!

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	cadent.proto

It has these top-level messages:
	ErrorResponse
	NoResponse
*/
package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import metrics "cadent/server/schemas/metrics"
import repr "cadent/server/schemas/repr"
import series "cadent/server/schemas/series"
import indexer "cadent/server/schemas/indexer"
import api "cadent/server/schemas/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ErrorResponse struct {
	Message string `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
	Code    int32  `protobuf:"varint,2,opt,name=code" json:"code,omitempty"`
}

func (m *ErrorResponse) Reset()                    { *m = ErrorResponse{} }
func (m *ErrorResponse) String() string            { return proto.CompactTextString(m) }
func (*ErrorResponse) ProtoMessage()               {}
func (*ErrorResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type NoResponse struct {
}

func (m *NoResponse) Reset()                    { *m = NoResponse{} }
func (m *NoResponse) String() string            { return proto.CompactTextString(m) }
func (*NoResponse) ProtoMessage()               {}
func (*NoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func init() {
	proto.RegisterType((*ErrorResponse)(nil), "ErrorResponse")
	proto.RegisterType((*NoResponse)(nil), "NoResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for CadentMetric service

type CadentMetricClient interface {
	// GetMetrics.
	//
	// Obtains Metrics from a metrics query.
	//
	GetMetrics(ctx context.Context, in *api.MetricQuery, opts ...grpc.CallOption) (CadentMetric_GetMetricsClient, error)
	// GetMetricsInCache.
	//
	// Obtains Metrics from a metrics query, but only if the metrics are in local cache.
	// Usefull for doing fanout queries where only one node may have the most recent data.
	// If multiple hosts return values for the same metric, it is up to the client to merge the streams.
	//
	GetMetricsInCache(ctx context.Context, in *api.MetricQuery, opts ...grpc.CallOption) (CadentMetric_GetMetricsInCacheClient, error)
	// Find.
	//
	// Find full Metrics from a indexer query.
	//
	Find(ctx context.Context, in *api.IndexQuery, opts ...grpc.CallOption) (CadentMetric_FindClient, error)
	// FindInCache.
	//
	// Find full metrics items that are in the local RAM index
	// Usefull for doing fanout queries where only one node may have the metric in the local ram index.
	// If multiple hosts return values for the same metric, it is up to the client to merge the streams.
	//
	FindInCache(ctx context.Context, in *api.IndexQuery, opts ...grpc.CallOption) (CadentMetric_FindInCacheClient, error)
	// List.
	//
	// return a big list of paths
	//
	List(ctx context.Context, in *api.IndexQuery, opts ...grpc.CallOption) (CadentMetric_ListClient, error)
	// PutRawMetric.
	//
	// Write a raw metric into the metric writer. This is a direct writer, it does not consistently hash.
	//
	PutRawMetric(ctx context.Context, in *series.RawMetric, opts ...grpc.CallOption) (*NoResponse, error)
	// PutStatRepr.
	//
	// Write a stat repr metric into the metric writer. This is a direct writer, it does not consistently hash.
	//
	PutStatRepr(ctx context.Context, in *repr.StatRepr, opts ...grpc.CallOption) (*NoResponse, error)
}

type cadentMetricClient struct {
	cc *grpc.ClientConn
}

func NewCadentMetricClient(cc *grpc.ClientConn) CadentMetricClient {
	return &cadentMetricClient{cc}
}

func (c *cadentMetricClient) GetMetrics(ctx context.Context, in *api.MetricQuery, opts ...grpc.CallOption) (CadentMetric_GetMetricsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CadentMetric_serviceDesc.Streams[0], c.cc, "/CadentMetric/GetMetrics", opts...)
	if err != nil {
		return nil, err
	}
	x := &cadentMetricGetMetricsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CadentMetric_GetMetricsClient interface {
	Recv() (*metrics.RawRenderItem, error)
	grpc.ClientStream
}

type cadentMetricGetMetricsClient struct {
	grpc.ClientStream
}

func (x *cadentMetricGetMetricsClient) Recv() (*metrics.RawRenderItem, error) {
	m := new(metrics.RawRenderItem)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cadentMetricClient) GetMetricsInCache(ctx context.Context, in *api.MetricQuery, opts ...grpc.CallOption) (CadentMetric_GetMetricsInCacheClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CadentMetric_serviceDesc.Streams[1], c.cc, "/CadentMetric/GetMetricsInCache", opts...)
	if err != nil {
		return nil, err
	}
	x := &cadentMetricGetMetricsInCacheClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CadentMetric_GetMetricsInCacheClient interface {
	Recv() (*metrics.RawRenderItem, error)
	grpc.ClientStream
}

type cadentMetricGetMetricsInCacheClient struct {
	grpc.ClientStream
}

func (x *cadentMetricGetMetricsInCacheClient) Recv() (*metrics.RawRenderItem, error) {
	m := new(metrics.RawRenderItem)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cadentMetricClient) Find(ctx context.Context, in *api.IndexQuery, opts ...grpc.CallOption) (CadentMetric_FindClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CadentMetric_serviceDesc.Streams[2], c.cc, "/CadentMetric/Find", opts...)
	if err != nil {
		return nil, err
	}
	x := &cadentMetricFindClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CadentMetric_FindClient interface {
	Recv() (*indexer.MetricFindItem, error)
	grpc.ClientStream
}

type cadentMetricFindClient struct {
	grpc.ClientStream
}

func (x *cadentMetricFindClient) Recv() (*indexer.MetricFindItem, error) {
	m := new(indexer.MetricFindItem)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cadentMetricClient) FindInCache(ctx context.Context, in *api.IndexQuery, opts ...grpc.CallOption) (CadentMetric_FindInCacheClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CadentMetric_serviceDesc.Streams[3], c.cc, "/CadentMetric/FindInCache", opts...)
	if err != nil {
		return nil, err
	}
	x := &cadentMetricFindInCacheClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CadentMetric_FindInCacheClient interface {
	Recv() (*indexer.MetricFindItem, error)
	grpc.ClientStream
}

type cadentMetricFindInCacheClient struct {
	grpc.ClientStream
}

func (x *cadentMetricFindInCacheClient) Recv() (*indexer.MetricFindItem, error) {
	m := new(indexer.MetricFindItem)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cadentMetricClient) List(ctx context.Context, in *api.IndexQuery, opts ...grpc.CallOption) (CadentMetric_ListClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CadentMetric_serviceDesc.Streams[4], c.cc, "/CadentMetric/List", opts...)
	if err != nil {
		return nil, err
	}
	x := &cadentMetricListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CadentMetric_ListClient interface {
	Recv() (*indexer.MetricFindItem, error)
	grpc.ClientStream
}

type cadentMetricListClient struct {
	grpc.ClientStream
}

func (x *cadentMetricListClient) Recv() (*indexer.MetricFindItem, error) {
	m := new(indexer.MetricFindItem)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cadentMetricClient) PutRawMetric(ctx context.Context, in *series.RawMetric, opts ...grpc.CallOption) (*NoResponse, error) {
	out := new(NoResponse)
	err := grpc.Invoke(ctx, "/CadentMetric/PutRawMetric", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cadentMetricClient) PutStatRepr(ctx context.Context, in *repr.StatRepr, opts ...grpc.CallOption) (*NoResponse, error) {
	out := new(NoResponse)
	err := grpc.Invoke(ctx, "/CadentMetric/PutStatRepr", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CadentMetric service

type CadentMetricServer interface {
	// GetMetrics.
	//
	// Obtains Metrics from a metrics query.
	//
	GetMetrics(*api.MetricQuery, CadentMetric_GetMetricsServer) error
	// GetMetricsInCache.
	//
	// Obtains Metrics from a metrics query, but only if the metrics are in local cache.
	// Usefull for doing fanout queries where only one node may have the most recent data.
	// If multiple hosts return values for the same metric, it is up to the client to merge the streams.
	//
	GetMetricsInCache(*api.MetricQuery, CadentMetric_GetMetricsInCacheServer) error
	// Find.
	//
	// Find full Metrics from a indexer query.
	//
	Find(*api.IndexQuery, CadentMetric_FindServer) error
	// FindInCache.
	//
	// Find full metrics items that are in the local RAM index
	// Usefull for doing fanout queries where only one node may have the metric in the local ram index.
	// If multiple hosts return values for the same metric, it is up to the client to merge the streams.
	//
	FindInCache(*api.IndexQuery, CadentMetric_FindInCacheServer) error
	// List.
	//
	// return a big list of paths
	//
	List(*api.IndexQuery, CadentMetric_ListServer) error
	// PutRawMetric.
	//
	// Write a raw metric into the metric writer. This is a direct writer, it does not consistently hash.
	//
	PutRawMetric(context.Context, *series.RawMetric) (*NoResponse, error)
	// PutStatRepr.
	//
	// Write a stat repr metric into the metric writer. This is a direct writer, it does not consistently hash.
	//
	PutStatRepr(context.Context, *repr.StatRepr) (*NoResponse, error)
}

func RegisterCadentMetricServer(s *grpc.Server, srv CadentMetricServer) {
	s.RegisterService(&_CadentMetric_serviceDesc, srv)
}

func _CadentMetric_GetMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.MetricQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CadentMetricServer).GetMetrics(m, &cadentMetricGetMetricsServer{stream})
}

type CadentMetric_GetMetricsServer interface {
	Send(*metrics.RawRenderItem) error
	grpc.ServerStream
}

type cadentMetricGetMetricsServer struct {
	grpc.ServerStream
}

func (x *cadentMetricGetMetricsServer) Send(m *metrics.RawRenderItem) error {
	return x.ServerStream.SendMsg(m)
}

func _CadentMetric_GetMetricsInCache_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.MetricQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CadentMetricServer).GetMetricsInCache(m, &cadentMetricGetMetricsInCacheServer{stream})
}

type CadentMetric_GetMetricsInCacheServer interface {
	Send(*metrics.RawRenderItem) error
	grpc.ServerStream
}

type cadentMetricGetMetricsInCacheServer struct {
	grpc.ServerStream
}

func (x *cadentMetricGetMetricsInCacheServer) Send(m *metrics.RawRenderItem) error {
	return x.ServerStream.SendMsg(m)
}

func _CadentMetric_Find_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.IndexQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CadentMetricServer).Find(m, &cadentMetricFindServer{stream})
}

type CadentMetric_FindServer interface {
	Send(*indexer.MetricFindItem) error
	grpc.ServerStream
}

type cadentMetricFindServer struct {
	grpc.ServerStream
}

func (x *cadentMetricFindServer) Send(m *indexer.MetricFindItem) error {
	return x.ServerStream.SendMsg(m)
}

func _CadentMetric_FindInCache_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.IndexQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CadentMetricServer).FindInCache(m, &cadentMetricFindInCacheServer{stream})
}

type CadentMetric_FindInCacheServer interface {
	Send(*indexer.MetricFindItem) error
	grpc.ServerStream
}

type cadentMetricFindInCacheServer struct {
	grpc.ServerStream
}

func (x *cadentMetricFindInCacheServer) Send(m *indexer.MetricFindItem) error {
	return x.ServerStream.SendMsg(m)
}

func _CadentMetric_List_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.IndexQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CadentMetricServer).List(m, &cadentMetricListServer{stream})
}

type CadentMetric_ListServer interface {
	Send(*indexer.MetricFindItem) error
	grpc.ServerStream
}

type cadentMetricListServer struct {
	grpc.ServerStream
}

func (x *cadentMetricListServer) Send(m *indexer.MetricFindItem) error {
	return x.ServerStream.SendMsg(m)
}

func _CadentMetric_PutRawMetric_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(series.RawMetric)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CadentMetricServer).PutRawMetric(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CadentMetric/PutRawMetric",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CadentMetricServer).PutRawMetric(ctx, req.(*series.RawMetric))
	}
	return interceptor(ctx, in, info, handler)
}

func _CadentMetric_PutStatRepr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(repr.StatRepr)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CadentMetricServer).PutStatRepr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CadentMetric/PutStatRepr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CadentMetricServer).PutStatRepr(ctx, req.(*repr.StatRepr))
	}
	return interceptor(ctx, in, info, handler)
}

var _CadentMetric_serviceDesc = grpc.ServiceDesc{
	ServiceName: "CadentMetric",
	HandlerType: (*CadentMetricServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PutRawMetric",
			Handler:    _CadentMetric_PutRawMetric_Handler,
		},
		{
			MethodName: "PutStatRepr",
			Handler:    _CadentMetric_PutStatRepr_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetMetrics",
			Handler:       _CadentMetric_GetMetrics_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetMetricsInCache",
			Handler:       _CadentMetric_GetMetricsInCache_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Find",
			Handler:       _CadentMetric_Find_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FindInCache",
			Handler:       _CadentMetric_FindInCache_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "List",
			Handler:       _CadentMetric_List_Handler,
			ServerStreams: true,
		},
	},
	Metadata: fileDescriptor0,
}

func init() { proto.RegisterFile("cadent.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 363 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x52, 0xc1, 0x4a, 0xeb, 0x40,
	0x14, 0x6d, 0xfa, 0xfa, 0xde, 0xe3, 0xdd, 0xe6, 0x55, 0x3b, 0x0b, 0x2d, 0x75, 0x53, 0x02, 0x42,
	0x45, 0x99, 0x14, 0xdb, 0x95, 0xe2, 0xc2, 0x16, 0x95, 0x82, 0x4a, 0x1c, 0x77, 0xee, 0xa6, 0x99,
	0x8b, 0xcd, 0x22, 0x99, 0x71, 0x66, 0x6a, 0xf5, 0x47, 0xfc, 0x5e, 0xc9, 0x24, 0x69, 0x41, 0x4a,
	0xa1, 0x9b, 0xdc, 0x9c, 0x70, 0xce, 0x3d, 0xe1, 0xdc, 0x03, 0x7e, 0xcc, 0x05, 0x66, 0x96, 0x2a,
	0x2d, 0xad, 0xec, 0x9e, 0x16, 0x28, 0x34, 0xa8, 0xdf, 0x51, 0x87, 0x26, 0x9e, 0x63, 0xca, 0x4d,
	0x98, 0xa2, 0xd5, 0x49, 0xbc, 0x9a, 0x25, 0xf9, 0x78, 0x33, 0x59, 0xa3, 0xd2, 0xee, 0x51, 0xd2,
	0x4e, 0x36, 0xd3, 0x0c, 0xea, 0x04, 0xab, 0xb1, 0xdd, 0x3e, 0xc9, 0x04, 0x7e, 0xa0, 0xae, 0xe6,
	0x76, 0x7b, 0xae, 0x92, 0xf0, 0x6d, 0x81, 0xfa, 0xb3, 0xa0, 0x05, 0x57, 0xf0, 0xff, 0x46, 0x6b,
	0xa9, 0x19, 0x1a, 0x25, 0x33, 0x83, 0xa4, 0x03, 0x7f, 0x53, 0x34, 0x86, 0xbf, 0x62, 0xc7, 0xeb,
	0x79, 0xfd, 0x7f, 0xac, 0x82, 0x84, 0x40, 0x23, 0x96, 0x02, 0x3b, 0xf5, 0x9e, 0xd7, 0xff, 0xcd,
	0xdc, 0x7b, 0xe0, 0x03, 0x3c, 0xca, 0x4a, 0x7b, 0xfe, 0xf5, 0x0b, 0xfc, 0x89, 0xb3, 0x7d, 0x70,
	0x51, 0x90, 0x0b, 0x80, 0x3b, 0x2c, 0x81, 0x21, 0xfb, 0x94, 0xab, 0x84, 0x16, 0xe8, 0x29, 0xff,
	0x87, 0xee, 0x01, 0xad, 0x32, 0x63, 0x7c, 0xc9, 0x30, 0x13, 0xa8, 0xa7, 0x16, 0xd3, 0xa0, 0x36,
	0xf0, 0xc8, 0x35, 0xb4, 0xd7, 0xda, 0x69, 0x36, 0xe1, 0xf1, 0x1c, 0x77, 0x5c, 0x31, 0x82, 0xc6,
	0x6d, 0x92, 0x09, 0xb2, 0xe7, 0x54, 0xd3, 0x3c, 0x9f, 0x42, 0x74, 0x48, 0xab, 0xb0, 0x8a, 0x55,
	0x39, 0x6b, 0xa5, 0xba, 0x84, 0xa6, 0xc3, 0xa5, 0xe5, 0x6e, 0xe2, 0x11, 0x34, 0xee, 0x13, 0x63,
	0x77, 0x54, 0x0d, 0xc0, 0x8f, 0x16, 0x96, 0xf1, 0x65, 0x99, 0x5b, 0x9b, 0x96, 0x87, 0x5f, 0x7d,
	0xea, 0x36, 0xe9, 0x3a, 0xe8, 0xa0, 0x46, 0xce, 0xa0, 0x19, 0x2d, 0xec, 0xb3, 0xe5, 0x96, 0xa1,
	0xd2, 0xa4, 0x45, 0x5d, 0xa5, 0x2a, 0xfc, 0x83, 0x3d, 0x1e, 0xc2, 0x51, 0x2c, 0x53, 0x6a, 0xe7,
	0xc8, 0x85, 0x40, 0x21, 0x33, 0x34, 0xb4, 0x6c, 0xb6, 0x56, 0xf1, 0xb8, 0x55, 0x1c, 0x8d, 0x45,
	0x93, 0x28, 0x2f, 0x45, 0xe4, 0xbd, 0xd4, 0xd5, 0x6c, 0xf6, 0xc7, 0x35, 0x64, 0xf8, 0x1d, 0x00,
	0x00, 0xff, 0xff, 0x34, 0x60, 0xfb, 0xca, 0x04, 0x03, 0x00, 0x00,
}
